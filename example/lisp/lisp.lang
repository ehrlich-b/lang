// Lisp reader - parses simple s-expressions into AST
// Supported forms:
//   - Numbers: 42
//   - Flat operations: + 1 2, - 3 4, * 5 6, / 7 8
//
// Note: This is a simple implementation without nested expression support
// (interpreter doesn't support recursive function calls yet)

// Reader entry point - parses "op num1 num2" or just "num"
reader lisp(text *u8) *u8 {
    var pos i64 = 0;
    var len i64 = str_len(text);

    // Skip leading whitespace
    while pos < len && is_space(peek_char(text, pos)) {
        pos = pos + 1;
    }

    // Check what we have
    var c i64 = peek_char(text, pos);

    // If it's a digit, parse a number
    if is_digit(c) {
        var num i64 = 0;
        while pos < len && is_digit(peek_char(text, pos)) {
            num = num * 10 + (peek_char(text, pos) - 48);
            pos = pos + 1;
        }
        return lang_number(num);
    }

    // Otherwise, expect operator followed by two numbers
    var op i64 = c;
    pos = pos + 1;

    // Skip whitespace
    while pos < len && is_space(peek_char(text, pos)) {
        pos = pos + 1;
    }

    // Parse first number
    var num1 i64 = 0;
    while pos < len && is_digit(peek_char(text, pos)) {
        num1 = num1 * 10 + (peek_char(text, pos) - 48);
        pos = pos + 1;
    }

    // Skip whitespace
    while pos < len && is_space(peek_char(text, pos)) {
        pos = pos + 1;
    }

    // Parse second number
    var num2 i64 = 0;
    while pos < len && is_digit(peek_char(text, pos)) {
        num2 = num2 * 10 + (peek_char(text, pos) - 48);
        pos = pos + 1;
    }

    // Build AST based on operator
    var left *u8 = lang_number(num1);
    var right *u8 = lang_number(num2);

    if op == 43 {  // '+'
        return lang_add(left, right);
    }
    if op == 45 {  // '-'
        return lang_sub(left, right);
    }
    if op == 42 {  // '*'
        return lang_mul(left, right);
    }
    if op == 47 {  // '/'
        return lang_div(left, right);
    }

    // Default: just return first number
    return left;
}
