// src/kernel_main.lang - Kernel entry point: AST -> platform code
//
// The kernel is the core compiler that processes S-expression AST.
// It ONLY knows AST - no lang syntax, no readers.
//
// Modes:
//   1. Normal: kernel input.ast -o output
//      Compile S-expression AST to platform code (x86 or LLVM IR)
//
//   2. Embed-self: kernel --embed-self kernel.ast -o kernel
//      Create self-aware kernel (one-time bootstrap operation)
//
//   3. Add reader: kernel -r name reader.ast -o new_kernel
//      Embed a reader into the kernel, producing a new compiler
//
// Environment:
//   LANGBE=llvm  - Output LLVM IR instead of x86 assembly
//   LANGOS=macos - Target macOS (affects LLVM triple)

// ============================================================
// Self-awareness: The kernel carries its own AST
// ============================================================
// This variable contains the kernel's own AST as an S-expression string.
// It starts as a placeholder "_" and gets populated by --embed-self.
// Each -r operation updates this to include the new reader.
var self_kernel *u8 = "_";


// Get argv[i]
func get_arg(argv **u8, i i64) *u8 {
    var base *u8 = argv;
    var p **u8 = base + (i * 8);
    return *p;
}

func read_file(path *u8) *u8 {
    var fd i64 = file_open(path, 0);  // O_RDONLY
    if fd < 0 {
        eprint("Error: cannot open file: ");
        eprintln(path);
        return nil;
    }

    var buf *u8 = alloc(4194304);  // 4MB max
    var n i64 = file_read(fd, buf, 4194304);
    file_close(fd);

    if n < 0 {
        eprintln("Error: cannot read file");
        return nil;
    }

    *(buf + n) = 0;
    return buf;
}

// Select backend based on LANGBE environment variable
func generate_output(prog *u8, output_file *u8) void {
    var langbe *u8 = getenv("LANGBE");
    if langbe != nil && streq(langbe, "llvm") {
        generate_llvm(prog, output_file);
    } else {
        generate(prog, output_file);
    }
}

// ============================================================
// AST Manipulation Helpers
// ============================================================

// Find a variable declaration by name in a program
// Returns the var_decl node or nil if not found
func find_var_in_program(prog *u8, name *u8) *u8 {
    var decls *u8 = program_decls(prog);
    var count i64 = program_decl_count(prog);
    var i i64 = 0;
    while i < count {
        var decl_ptr **u8 = decls + (i * 8);
        var decl *u8 = *decl_ptr;
        if node_kind(decl) == NODE_VAR_DECL {
            var decl_name *u8 = var_decl_name(decl);
            var decl_name_len i64 = var_decl_name_len(decl);
            if strlen(name) == decl_name_len {
                if memcmp(name, decl_name, decl_name_len) {
                    return decl;
                }
            }
        }
        i = i + 1;
    }
    return nil;
}

// Create a new string expression node
func make_string_expr(s *u8, len i64) *u8 {
    var node *u8 = string_expr_alloc();
    string_expr_set_value(node, s);
    string_expr_set_value_len(node, len);
    return node;
}

// Replace the initializer of a var declaration
func replace_var_init(var_decl *u8, new_init *u8) void {
    var_decl_set_init(var_decl, new_init);
}

// Combine two programs by concatenating their declarations
// Returns a new program node with all decls from both
func combine_programs(prog1 *u8, prog2 *u8) *u8 {
    var decls1 *u8 = program_decls(prog1);
    var count1 i64 = program_decl_count(prog1);
    var decls2 *u8 = program_decls(prog2);
    var count2 i64 = program_decl_count(prog2);

    var total i64 = count1 + count2;
    var combined_decls *u8 = alloc(total * 8);

    // Copy decls from prog1
    var i i64 = 0;
    while i < count1 {
        var src **u8 = decls1 + (i * 8);
        var dst **u8 = combined_decls + (i * 8);
        *dst = *src;
        i = i + 1;
    }

    // Copy decls from prog2
    i = 0;
    while i < count2 {
        var src **u8 = decls2 + (i * 8);
        var dst **u8 = combined_decls + ((count1 + i) * 8);
        *dst = *src;
        i = i + 1;
    }

    // Build new program node
    var prog *u8 = alloc(16);
    var pd **u8 = prog;
    *pd = combined_decls;
    var pc *i64 = prog + 8;
    *pc = total;

    return prog;
}

func main(argc i64, argv **u8) i64 {
    // Parse arguments
    var input_file *u8 = nil;
    var output_file *u8 = nil;
    var embed_self_file *u8 = nil;     // --embed-self kernel.ast
    var reader_name *u8 = nil;         // -r name
    var reader_file *u8 = nil;         // -r name <file>

    var i i64 = 1;
    while i < argc {
        var arg *u8 = get_arg(argv, i);

        // -o output
        if *arg == '-' && *(arg + 1) == 'o' && *(arg + 2) == 0 {
            i = i + 1;
            if i < argc {
                output_file = get_arg(argv, i);
            }
            i = i + 1;
            continue;
        }

        // -r name file (add reader mode)
        if *arg == '-' && *(arg + 1) == 'r' && *(arg + 2) == 0 {
            i = i + 1;
            if i < argc {
                reader_name = get_arg(argv, i);
            }
            i = i + 1;
            if i < argc {
                reader_file = get_arg(argv, i);
            }
            i = i + 1;
            continue;
        }

        // --embed-self kernel.ast
        if *arg == '-' && *(arg + 1) == '-' {
            if memcmp(arg + 2, "embed-self", 10) {
                i = i + 1;
                if i < argc {
                    embed_self_file = get_arg(argv, i);
                }
                i = i + 1;
                continue;
            }
        }

        // Input file
        input_file = arg;
        i = i + 1;
    }

    if output_file == nil {
        output_file = "a.out";
    }

    // ================================================================
    // EMBED-SELF MODE: kernel --embed-self kernel.ast -o kernel
    // Creates a self-aware kernel (one-time bootstrap operation)
    // ================================================================
    if embed_self_file != nil {
        // Read the kernel AST from file
        var kernel_source *u8 = read_file(embed_self_file);
        if kernel_source == nil {
            return 1;
        }

        // Parse AST
        var prog *u8 = parse_ast_from_string(kernel_source);
        if prog == nil {
            eprintln("Error: failed to parse kernel AST");
            return 1;
        }

        // Find self_kernel variable
        var self_var *u8 = find_var_in_program(prog, "self_kernel");
        if self_var == nil {
            eprintln("Error: self_kernel variable not found in AST");
            return 1;
        }

        // Replace self_kernel's initializer with the raw file contents
        var source_len i64 = strlen(kernel_source);
        var new_init *u8 = make_string_expr(kernel_source, source_len);
        replace_var_init(self_var, new_init);

        // Generate the self-aware kernel
        generate_output(prog, output_file);

        print("Wrote self-aware kernel to ");
        println(output_file);
        return 0;
    }

    // ================================================================
    // ADD READER MODE: kernel -r name reader.ast -o new_kernel
    // Embeds a reader into the kernel
    // ================================================================
    if reader_name != nil && reader_file != nil {
        // The kernel must already be self-aware (have self_kernel populated)
        if streq(self_kernel, "_") {
            eprintln("Error: kernel is not self-aware (self_kernel is placeholder)");
            eprintln("Run --embed-self first to create a self-aware kernel");
            return 1;
        }

        // Parse the kernel's own AST
        var kernel_prog *u8 = parse_ast_from_string(self_kernel);
        if kernel_prog == nil {
            eprintln("Error: failed to parse self_kernel AST");
            return 1;
        }

        // Read and parse the reader AST
        var reader_source *u8 = read_file(reader_file);
        if reader_source == nil {
            return 1;
        }
        var reader_prog *u8 = parse_ast_from_string(reader_source);
        if reader_prog == nil {
            eprintln("Error: failed to parse reader AST");
            return 1;
        }

        // Combine kernel + reader
        var combined *u8 = combine_programs(kernel_prog, reader_prog);

        // Find self_kernel in combined and update it
        var self_var *u8 = find_var_in_program(combined, "self_kernel");
        if self_var == nil {
            eprintln("Error: self_kernel not found in combined AST");
            return 1;
        }

        // Stringify the combined AST and update self_kernel
        var new_ast *u8 = ast_emit_program(combined);
        var new_init *u8 = make_string_expr(new_ast, strlen(new_ast));
        replace_var_init(self_var, new_init);

        // Generate new kernel with reader
        generate_output(combined, output_file);

        print("Wrote kernel with reader '");
        print(reader_name);
        print("' to ");
        println(output_file);
        return 0;
    }

    // ================================================================
    // NORMAL MODE: kernel input.ast -o output
    // ================================================================
    if input_file == nil {
        eprintln("Usage:");
        eprintln("  kernel <input.ast> -o output       Compile AST");
        eprintln("  kernel --embed-self k.ast -o k     Create self-aware kernel");
        eprintln("  kernel -r name reader.ast -o k     Add reader to kernel");
        return 1;
    }

    var ast_source *u8 = read_file(input_file);
    if ast_source == nil {
        return 1;
    }

    var prog *u8 = parse_ast_from_string(ast_source);
    if prog == nil {
        eprintln("Error: failed to parse AST");
        return 1;
    }

    generate_output(prog, output_file);

    print("Wrote ");
    println(output_file);
    return 0;
}
