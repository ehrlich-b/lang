// expect: 0
// Test: Closures created inside loops
// Each iteration creates a NEW closure with the CURRENT value

include "std/core.lang"

// Test 1: Create closure each iteration, call immediately
func test_closure_in_loop() i64 {
    var sum i64 = 0;
    var i i64 = 0;

    while i < 5 {
        var n i64 = i * 2;  // 0, 2, 4, 6, 8
        var f closure() i64 = fn() i64 { return n; };
        sum = sum + f();
        i = i + 1;
    }

    // sum = 0 + 2 + 4 + 6 + 8 = 20
    if sum != 20 {
        return 1;
    }
    return 0;
}

// Test 2: Create closure that uses loop counter
func test_loop_counter_capture() i64 {
    var result i64 = 0;
    var i i64 = 0;

    while i < 4 {
        var f closure(i64) i64 = fn(x i64) i64 { return x + i; };
        result = result + f(10);  // 10+0, 10+1, 10+2, 10+3
        i = i + 1;
    }

    // 10 + 11 + 12 + 13 = 46
    if result != 46 {
        return 2;
    }
    return 0;
}

// Test 3: Nested loops with closures
func test_nested_loop_closure() i64 {
    var sum i64 = 0;
    var i i64 = 0;

    while i < 3 {
        var j i64 = 0;
        while j < 3 {
            var f closure() i64 = fn() i64 { return i * 10 + j; };
            sum = sum + f();
            j = j + 1;
        }
        i = i + 1;
    }

    // (0+1+2) + (10+11+12) + (20+21+22) = 3 + 33 + 63 = 99
    if sum != 99 {
        return 3;
    }
    return 0;
}

func main() i64 {
    var r i64 = test_closure_in_loop();
    if r != 0 { return r; }

    r = test_loop_counter_capture();
    if r != 0 { return r; }

    r = test_nested_loop_closure();
    if r != 0 { return r; }

    return 0;
}
