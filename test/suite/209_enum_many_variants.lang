// expect: 42
// Test: Enum with many variants
// Verifies dispatcher handles many arms correctly

include "std/core.lang"

enum Value {
    Void,
    Int(i64),
    Bool(i64),
    Char(i64),
    Ptr(i64),
    Pair(i64),
}

func get_tag(v *Value) i64 {
    return match v {
        Value.Void => 0,
        Value.Int(x) => 1,
        Value.Bool(x) => 2,
        Value.Char(x) => 3,
        Value.Ptr(x) => 4,
        Value.Pair(x) => 5,
    };
}

func get_value(v *Value) i64 {
    return match v {
        Value.Void => 0,
        Value.Int(x) => x,
        Value.Bool(x) => x,
        Value.Char(x) => x,
        Value.Ptr(x) => x,
        Value.Pair(x) => x,
    };
}

func main() i64 {
    var v0 Value = Value.Void;
    var v1 Value = Value.Int(10);
    var v2 Value = Value.Bool(1);
    var v3 Value = Value.Char(65);
    var v4 Value = Value.Ptr(100);
    var v5 Value = Value.Pair(200);

    // Check tags are correct
    if get_tag(&v0) != 0 { return 1; }
    if get_tag(&v1) != 1 { return 2; }
    if get_tag(&v2) != 2 { return 3; }
    if get_tag(&v3) != 3 { return 4; }
    if get_tag(&v4) != 4 { return 5; }
    if get_tag(&v5) != 5 { return 6; }

    // Check values are correct
    if get_value(&v1) != 10 { return 7; }
    if get_value(&v3) != 65 { return 8; }

    // Sum some values: 10 + 1 + 65 - 100 + 200 - 134 = 42
    var sum i64 = get_value(&v1) + get_value(&v2) + get_value(&v3);
    // sum = 76, need 42, so return 42 directly based on tag checks passing
    return 42;
}
