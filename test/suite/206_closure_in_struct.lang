// expect: 0
// Test: Closures stored in struct fields

include "std/core.lang"

// Callback holder
struct CallbackHolder {
    cb *u8;  // Store closure as *u8 (opaque pointer)
}

// Helper to call a stored closure
func call_cb(holder *CallbackHolder) i64 {
    var clos *u8 = holder.cb;
    // Cast to closure type and call
    // Using manual calling since the field is *u8
    var fn_ptr_p **u8 = clos + 8;
    var fn_ptr *u8 = *fn_ptr_p;
    var tag_p *i64 = clos;
    var tag i64 = *tag_p;

    if tag == 0 {
        // Non-capturing: call directly
        var f fn() i64 = fn_ptr;
        return f();
    } else {
        // Capturing: pass closure as first arg
        var f fn(*u8) i64 = fn_ptr;
        return f(clos);
    }
}

// Test 1: Store non-capturing closure in struct
func test_store_simple() i64 {
    var holder *CallbackHolder = alloc(8);

    var f closure() i64 = fn() i64 { return 42; };
    holder.cb = f;

    var result i64 = call_cb(holder);
    if result != 42 {
        return 1;
    }
    return 0;
}

// Test 2: Store capturing closure in struct
func test_store_capturing() i64 {
    var holder *CallbackHolder = alloc(8);

    var n i64 = 42;
    var f closure() i64 = fn() i64 { return n; };
    holder.cb = f;

    var result i64 = call_cb(holder);
    if result != 42 {
        return 2;
    }
    return 0;
}

// Test 3: Multiple closures in struct
struct TwoCallbacks {
    first *u8;
    second *u8;
}

func call_tc_first(tc *TwoCallbacks) i64 {
    var clos *u8 = tc.first;
    var fn_ptr_p **u8 = clos + 8;
    var fn_ptr *u8 = *fn_ptr_p;
    var tag_p *i64 = clos;
    var tag i64 = *tag_p;
    if tag == 0 {
        var f fn() i64 = fn_ptr;
        return f();
    } else {
        var f fn(*u8) i64 = fn_ptr;
        return f(clos);
    }
}

func call_tc_second(tc *TwoCallbacks) i64 {
    var clos *u8 = tc.second;
    var fn_ptr_p **u8 = clos + 8;
    var fn_ptr *u8 = *fn_ptr_p;
    var tag_p *i64 = clos;
    var tag i64 = *tag_p;
    if tag == 0 {
        var f fn() i64 = fn_ptr;
        return f();
    } else {
        var f fn(*u8) i64 = fn_ptr;
        return f(clos);
    }
}

func test_multiple_in_struct() i64 {
    var tc *TwoCallbacks = alloc(16);

    var a i64 = 20;
    var b i64 = 22;

    var f1 closure() i64 = fn() i64 { return a; };
    var f2 closure() i64 = fn() i64 { return b; };

    tc.first = f1;
    tc.second = f2;

    var r1 i64 = call_tc_first(tc);
    var r2 i64 = call_tc_second(tc);

    if r1 + r2 != 42 {
        return 3;
    }
    return 0;
}

func main() i64 {
    var r i64 = test_store_simple();
    if r != 0 { return r; }

    r = test_store_capturing();
    if r != 0 { return r; }

    r = test_multiple_in_struct();
    if r != 0 { return r; }

    return 0;
}
