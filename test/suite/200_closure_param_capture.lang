// expect: 0
// Test: Closure captures function parameters (not just local variables)

include "std/core.lang"

// Test 1: Capture single parameter
func make_adder(n i64) closure(i64) i64 {
    return fn(x i64) i64 { return x + n; };
}

func test_param_capture() i64 {
    var add5 closure(i64) i64 = make_adder(5);
    var result i64 = add5(37);
    if result != 42 {
        return 1;
    }
    return 0;
}

// Test 2: Capture multiple parameters
func make_linear(a i64, b i64) closure(i64) i64 {
    return fn(x i64) i64 { return a * x + b; };
}

func test_multi_param_capture() i64 {
    var f closure(i64) i64 = make_linear(4, 2);  // 4x + 2
    var result i64 = f(10);  // 4*10 + 2 = 42
    if result != 42 {
        return 2;
    }
    return 0;
}

// Test 3: Capture parameter and local
func make_combined(multiplier i64) closure(i64) i64 {
    var offset i64 = 2;
    return fn(x i64) i64 { return x * multiplier + offset; };
}

func test_param_and_local() i64 {
    var f closure(i64) i64 = make_combined(4);  // x*4 + 2
    var result i64 = f(10);  // 10*4 + 2 = 42
    if result != 42 {
        return 3;
    }
    return 0;
}

// Test 4: Multiple closures from same function call
func make_pair(n i64) i64 {
    var inc closure(i64) i64 = fn(x i64) i64 { return x + n; };
    var dec closure(i64) i64 = fn(x i64) i64 { return x - n; };

    var x i64 = 42;
    x = inc(x);   // 42 + n
    x = dec(x);   // back to 42
    return x;
}

func test_multiple_closures_same_param() i64 {
    var result i64 = make_pair(10);
    if result != 42 {
        return 4;
    }
    return 0;
}

func main() i64 {
    var r i64 = test_param_capture();
    if r != 0 { return r; }

    r = test_multi_param_capture();
    if r != 0 { return r; }

    r = test_param_and_local();
    if r != 0 { return r; }

    r = test_multiple_closures_same_param();
    if r != 0 { return r; }

    return 0;
}
