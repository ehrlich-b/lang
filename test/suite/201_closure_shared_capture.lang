// expect: 0
// Test: Multiple closures capturing the same variable
// Each closure gets its own COPY (value semantics)

include "std/core.lang"

// Test 1: Two closures share one captured variable
func test_shared_capture() i64 {
    var n i64 = 5;

    var add_n closure(i64) i64 = fn(x i64) i64 { return x + n; };
    var mul_n closure(i64) i64 = fn(x i64) i64 { return x * n; };

    var sum i64 = add_n(10);   // 10 + 5 = 15
    var prod i64 = mul_n(6);   // 6 * 5 = 30

    if sum + prod != 45 {
        return 1;
    }
    return 0;
}

// Test 2: Closures created at different points capture same value
func test_capture_at_creation() i64 {
    var n i64 = 10;
    var f1 closure() i64 = fn() i64 { return n; };  // Captures 10

    n = 20;
    var f2 closure() i64 = fn() i64 { return n; };  // Captures 20

    n = 30;  // Modify again - shouldn't affect either closure

    var v1 i64 = f1();
    var v2 i64 = f2();

    // f1 should have 10, f2 should have 20
    if v1 + v2 != 30 {
        return 2;
    }
    return 0;
}

// Test 3: Three closures, different combinations of captures
func test_three_closures() i64 {
    var a i64 = 10;
    var b i64 = 5;

    var f1 closure() i64 = fn() i64 { return a; };      // Just a
    var f2 closure() i64 = fn() i64 { return b; };      // Just b
    var f3 closure() i64 = fn() i64 { return a + b; };  // Both

    var r1 i64 = f1();
    var r2 i64 = f2();
    var r3 i64 = f3();

    if r1 != 10 { return 31; }
    if r2 != 5 { return 32; }
    if r3 != 15 { return 33; }

    return 0;
}

func main() i64 {
    var r i64 = test_shared_capture();
    if r != 0 { return r; }

    r = test_capture_at_creation();
    if r != 0 { return r; }

    r = test_three_closures();
    if r != 0 { return r; }

    return 0;
}
