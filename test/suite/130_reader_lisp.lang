// expect: 42
// Test: lisp reader macro

// Lisp reader for simple expressions
reader lisp(text *u8) *u8 {
    var pos i64 = 0;
    var len i64 = str_len(text);

    // Skip whitespace
    while pos < len && is_space(peek_char(text, pos)) {
        pos = pos + 1;
    }

    var c i64 = peek_char(text, pos);

    // Number
    if is_digit(c) {
        var num i64 = 0;
        while pos < len && is_digit(peek_char(text, pos)) {
            num = num * 10 + (peek_char(text, pos) - 48);
            pos = pos + 1;
        }
        return lang_number(num);
    }

    // Operator + two numbers
    var op i64 = c;
    pos = pos + 1;

    while pos < len && is_space(peek_char(text, pos)) {
        pos = pos + 1;
    }

    var num1 i64 = 0;
    while pos < len && is_digit(peek_char(text, pos)) {
        num1 = num1 * 10 + (peek_char(text, pos) - 48);
        pos = pos + 1;
    }

    while pos < len && is_space(peek_char(text, pos)) {
        pos = pos + 1;
    }

    var num2 i64 = 0;
    while pos < len && is_digit(peek_char(text, pos)) {
        num2 = num2 * 10 + (peek_char(text, pos) - 48);
        pos = pos + 1;
    }

    var left *u8 = lang_number(num1);
    var right *u8 = lang_number(num2);

    if op == 43 { return lang_add(left, right); }
    if op == 45 { return lang_sub(left, right); }
    if op == 42 { return lang_mul(left, right); }
    if op == 47 { return lang_div(left, right); }

    return left;
}

func main() i64 {
    // (* 6 7) = 42
    return #lisp{* 6 7};
}
